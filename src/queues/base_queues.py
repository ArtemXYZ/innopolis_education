"""
    Модуль содержит реализации различных типов очередей.
    ------------------------------------------------------------------------------------------------------------
    |       Характеристика         | Простая     |                              |                              |
    |                              | очередь     |                              |                              |
    |                              | (list)      |      collections.deque       | Приоритетная очередь (heapq) |
    ------------------------------------------------------------------------------------------------------------
    | Временная сложность Enqueue  |  O(1)       |             O(1)             |           O(log n)           |
    | Временная сложность Dequeue  |  O(n)       |             O(1)             |           O(log n)           |
    | Порядок обработки элементов  |  FIFO       |        FIFO или LIFO         |        По приоритету         |
    |     Простота реализации      |  Простая    |          Умеренная           |           Средняя            |
    |      Потокобезопасность      |  Нет        |             Нет              |             Нет              |
    |       Многопоточность        |  Ограничена |          Ограничена          |          Ограничена          |
    |     Использование памяти     |  Высокое    |            Низкое            |            Низкое            |
    |
    ------------------------------------------------------------------------------------------------------------

"""

from collections import deque
import heapq


# ----------------------------------------------------------------------------------------------------------------------
class BaseSimpleQueue:
    """
        Класс содержит кастомную реализацию "простой очереди".
    """

    def __init__(self):
        self.queue = []

    def enqueue(self, item):
        """Добавляет элемент в конец очереди."""
        self.queue.append(item)

    def dequeue(self):
        """Удаляет и возвращает элемент из начала очереди."""
        if not self.is_empty():
            return self.queue.pop(0)
        raise IndexError("dequeue from empty queue")

    def is_empty(self):
        """Проверяет, пуста ли очередь."""
        return len(self.queue) == 0

    def size(self):
        """Возвращает количество элементов в очереди."""
        return len(self.queue)


class BaseDequeQueue:
    """
        * Класс содержит адаптацию стандартного модуля queue ("двусторонней очереди").
        Работает только с началом очереди (popleft()).

            Модуль deque из библиотеки collections в Python представляет собой двустороннюю очередь
            (double-ended queue). Название "deque" является сокращением от "double-ended queue".

        * Основные особенности deque:

            - Это структура данных, которая позволяет добавлять и удалять элементы как с начала, так и с конца очереди.
            - Она оптимизирована для быстрых операций добавления и удаления элементов с обоих концов (в среднем O(1)).
            - deque может быть использован как стек (LIFO) или очередь (FIFO).

        * Пример использования BaseDequeQueue:

            dq = BaseDequeQueue()
            dq.enqueue(1)
            dq.enqueue(2)
            dq.enqueue(3)
            print(dq.dequeue())  # 1
            print(dq.size())     # 2

        * Пример синтаксиса deque:

            # Создание deque
            d = deque([1, 2, 3])

            # Добавление элемента в конец
            d.append(4)  # deque([1, 2, 3, 4])

            # Добавление элемента в начало
            d.appendleft(0)  # deque([0, 1, 2, 3, 4])

            # Удаление элемента с конца
            d.pop()  # 4, deque([0, 1, 2, 3])

            # Удаление элемента с начала
            d.popleft()  # 0, deque([1, 2, 3])
    """

    def __init__(self):
        self.queue = deque()

    def enqueue(self, item):
        """Добавляет элемент в конец очереди."""
        self.queue.append(item)

    def dequeue(self):
        """Удаляет и возвращает элемент из начала очереди."""
        if not self.is_empty():
            return self.queue.popleft()
        raise IndexError("dequeue from empty queue")

    def is_empty(self):
        """Проверяет, пуста ли очередь."""
        return len(self.queue) == 0

    def size(self):
        """Возвращает количество элементов в очереди."""
        return len(self.queue)


class BasePriorityQueue:
    """
        * Класс содержит адаптацию стандартного модуля heapq ("кучи") для работы с приоритетными очередями.

            Модуль heapq в Python предоставляет реализацию кучи (heap) — специальной структуры данных,
            которая позволяет эффективно работать с приоритетными очередями. Куча — это бинарное дерево,
            в котором каждый родительский узел меньше или равен своим дочерним узлам (в случае min-heap).
            Это свойство позволяет быстро извлекать минимальный элемент и эффективно добавлять новые элементы.

        * Когда использовать heapq?
            - Когда нужно работать с приоритетной очередью (например, в алгоритмах, где важно извлекать минимальный
            или максимальный элемент).
            - В задачах, где требуется эффективное управление динамическими данными с частыми вставками и извлечениями.

        * Важно:
            По умолчанию heapq реализует min-heap, то есть наименьший элемент всегда находится в корне.
            Если нужна max-heap, можно инвертировать значения (например, умножать на -1).

        * Основные функции модуля heapq:

            heapq.heappush(heap, item)
            Добавляет элемент item в кучу heap, сохраняя свойства кучи.

            heapq.heappop(heap)
            Удаляет и возвращает наименьший элемент из кучи heap.

            heapq.heappushpop(heap, item)
            Добавляет элемент item в кучу и сразу извлекает наименьший элемент. Это более эффективно,
            чем выполнять heappush и heappop по отдельности.

            heapq.heapreplace(heap, item)
            Извлекает наименьший элемент из кучи и добавляет новый элемент item.
            Отличается от heappushpop порядком операций: сначала извлечение, потом добавление.

            heapq.heapify(x)
            Преобразует список x в кучу за время O(n).

            heapq.nlargest(n, iterable[, key])
            Возвращает n наибольших элементов из iterable.

            heapq.nsmallest(n, iterable[, key])
            Возвращает n наименьших элементов из iterable.

        * Пример использования BasePriorityQueue:

            pq = BasePriorityQueue()
            pq.enqueue(2, 'low')
            pq.enqueue(1, 'high')
            print(pq.dequeue())  # 'high'
            print(pq.size())  # 1

        * Пример синтаксиса heapq:

            import heapq

            # Создаем список
            data = [5, 3, 8, 1, 2]

            # Преобразуем список в кучу (min-heap)
            heapq.heapify(data)
            print("Куча:", data)  # [1, 2, 8, 3, 5]

            # Добавляем элемент в кучу
            heapq.heappush(data, 4)
            print("Куча после добавления 4:", data)  # [1, 2, 4, 3, 5, 8]

            # Извлекаем минимальный элемент
            min_element = heapq.heappop(data)
            print("Минимальный элемент:", min_element)  # 1
            print("Куча после извлечения:", data)  # [2, 3, 4, 8, 5]
    """

    def __init__(self):
        self.queue = []

    def enqueue(self, priority, item):
        """Добавляет элемент в очередь с приоритетом."""
        heapq.heappush(self.queue, (priority, item))

    def dequeue(self):
        """Удаляет и возвращает элемент с наивысшим приоритетом."""
        if not self.is_empty():
            return heapq.heappop(self.queue)[1]
        raise IndexError("dequeue from empty queue")

    def is_empty(self):
        """Проверяет, пуста ли очередь."""
        return len(self.queue) == 0

    def size(self):
        """Возвращает количество элементов в очереди."""
        return len(self.queue)
